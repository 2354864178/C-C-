===== 开始 List 测试 =====

=== 测试：构造与基本功能 ===
list1 (默认构造) 元素：空列表
list1 插入后 元素：1 2 3 (大小: 3)
list2 (list1 的拷贝) 元素：1 2 3 (大小: 3)
list3 (区间构造) 元素：2 3 (大小: 2)
list4 (按索引区间构造) 元素：2 3 (大小: 2)

=== 测试：删除与清空 ===
原始列表 元素：1 2 3 4 5 (大小: 5)
删除后的列表 元素：1 3 4 5 (大小: 4)
清空后的列表 元素：空列表

=== 测试：查找功能 ===
查找测试列表 元素：1 2 3 4 5 (大小: 5)

=== 测试：search 功能 ===
供 search 使用的有序列表 元素：1 3 5 (大小: 3)
p1=0x61183013e300 data=3
p2=0x61183013e300 data=3
p3=0 (null)

=== 测试：查找最大元素 ===
供 selectMax 使用的列表 元素：3 5 2 7 1 (大小: 5)

=== 测试：去重功能 ===
去重前（无序） 元素：3 1 3 2 1 (大小: 5)
去重后（无序） 元素：3 2 1 (大小: 3)
去重前（有序） 元素：1 1 2 2 3 (大小: 5)
去重后（有序） 元素：1 2 3 (大小: 3)

=== 测试：排序功能 ===
插入排序前(list1) 元素：3 1 4 2 (大小: 4)
插入排序：n=4
  插入排序轮次 r=1 值=1
    选定 q=<头结点>
  插入排序轮次 r=2 值=4
    选定 q=3
  插入排序轮次 r=3 值=2
    选定 q=1
插入排序后(list1) 元素：1 2 3 4 (大小: 4)
选择排序前(list2) 元素：5 3 8 6 2 (大小: 5)
选择排序后(list2) 元素：2 3 5 6 8 (大小: 5)

=== 测试：反转 ===
反转前 元素：1 2 3 4 5 (大小: 5)
  first()=0x61183013e460 last()=0x61183013e3e0
反转：大小=5
  swap i=0 values=1,5
  swap i=1 values=2,4
反转完成
反转后 元素：5 4 3 2 1 (大小: 5)
  first()=0x61183013e460 last()=0x61183013e3e0

=== 测试：异常处理 ===
通过：已捕获 out_of_range 异常

===== 所有 List 测试通过 =====
===== 开始 Vector 测试 =====
运行构造函数测试...
vec1 初始: 大小=0
vec2 初始化 (容量=10, 大小=5, 值=1): 1 1 1 1 1 
vec3 从数组构造: 1 2 3 4 5 
通过!
运行插入操作测试...
插入前 vec: 大小=0
插入后 vec 内容: 10 15 20 25 
通过!
运行删除操作测试...
构造查找/搜索测试 vec 初始 (空)
通过!
运行查找操作测试...
冒泡排序之后: 10 20 30 
通过!
运行排序操作测试...
构造排序测试 vec 初始 (大小=0)
冒泡排序结果: 10,20,30
选择排序结果: 10 20 25 30 
插入排序结果: 5 10 20 25 30 
归并排序结果: 5 10 20 25 30 
通过!
运行唯一化操作测试...
构造唯一化测试 vec 初始
通过!
运行置乱和遍历操作测试...
构造置乱与遍历测试 vec 初始
置乱后: 30 10 20 
通过!

===== 所有测试通过 =====
===== 开始 栈/队列 测试 =====
Stack: 初始 size=0
Stack: push 10
Stack: push 20
Stack: push 30
Stack: size=3
Stack: top=30 pop=30
Stack: top=20
Stack: after pops size=0
Queue: 初始 size=0
Queue: enqueue 1
Queue: enqueue 2
Queue: enqueue 3
Queue: size=3 front=1
Queue: dequeue=1
Queue: front=2
Queue: dequeue rest
Queue: after dequeues size=0
===== 栈/队列 测试通过 =====
===== 开始 BinNode 测试 =====
构建根节点 10 并插入左右子节点 5,15
left->succ() == 10 root.succ() == 15
中序遍历收集结果...
先序遍历收集结果...
后序遍历收集结果...
===== BinNode 测试通过 =====
===== 开始 BinTree 测试 =====
构建树并插入节点: 10, 5, 15, 3,7,13,17
当前树大小 T.size()=7
进行中序遍历...
进行先序遍历...
删除子树 (a) ...
删除节点数量: 3 剩余 T.size()=4
分离子树 b ...
分离后子树大小 sub->size()=3 总树大小 T.size()=1
===== BinTree 测试通过 =====
